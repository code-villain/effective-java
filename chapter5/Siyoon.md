# item26) 로 타입은 사용하지 말라

## 정의
### 타입 매개변수(type parameter)
꺽쇠 < > 안에 들어가는 타입 한정자 매개변수

### 제네릭 클래스 (제네릭 인터페이스)
타입 매개변수를 사용한 클래스 (혹은 인터페이스)

### 제네릭 타입
제네릭 클래스 + 제네릭 인터페이스를 통틀어 제네릭 타입이라고 한다.

### 로(raw) 타입
제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다. (즉 제네릭 타입이 아닌 클래스는 로타입이라고 부르지 않는 다는 것이군)

로타입은 1.5버전 이하의 호환성을 위해서 가능하게 한것이다. 안정성과 표현력(가독성)을 떨어뜨린다. 절대로 사용해서는 안된다.

# item27) 비검사 경고를 제거하라.

= 컴파일러 (혹은 IDE) 말을 잘 듣자. 타입 안정성이 보장된다.

개발자가 보증할 수 있지만 경고를 제거 할 수 없는 경우에는 @SuperessWarnings 애노테이션을 달자. 가능한 좁은 범위에 달아야 한다.

# item28) 배열보다는 리스트를 사용하라.

= 배열보다는 '제네릭 타입인' 리스트를 사용하라. (그러나 리스트는 자바의 기본 타입이 아니다. 내부 구현시에 결국 배열을 사용해야 하는 경우가 있다. 아이템 29 참고)

## 배열 vs (제네릭타입) 리스트

### 공변(covariant) vs 불공변(invariant)
배열은 공변이다. 말이 어려운데 String[]은 Object[]의 하위타입이 된다. 다형성의 관점에서 생각해보자. 매개변수 타입이 Object[]로 되어 있다면 String[]도 받아들일 수 있다. 

반면에 (제네릭 타입) 리스트는 List<String>과 List<Object>는 엄밀히 구분된다. 매개변수 타입이 List<Object>라도 List<String>은 받을 수 없다. 다형적으로 받기 위해서 와일드카드<?>를 이떄 사용한다.

### 실체화(reifiable) vs 실체화 불가(non-reifiable)
제네릭 타입정보는 컴파일 이후에는 사라진다. 컴파일 이전까지만 타입안정성을 검사하고 '실체화'되지 않는다. 반면에 배열은 컴파일 이후에도 타입이 남아 '실체화' 된다. 이 때문에 배열과 (제네릭 타입인) 리스트를 섞어서 어우러지게 쓰기 어려운 것이다. 제네릭 타입은 타입 안정성을 추구해야 하는데, 실체화되지 않는 상황에서 배열에 들어가게 되면 이러한 강점이 사라지기 때문이다. 그래서 리스트 배열을 만드는 것은 불가능하도록 설정되었다. (페이지 165쪽)

# item 29) 이왕이면 제네릭 타입으로 만들라

## 왜 제네릭 타입으로 만들어야 하는가? 
1. 타입 안정성과 가독성을 올릴 수 있다.
2. 클라이언트가 사용하기 편하다. (직접 형변환 하지 않아도 된다.)

## 배열을 사용하는 제네릭 타입 만들기
제네릭 타입은 실체화 되지 않으므로 배열에 사용하게 되면 컴파일 '오류'를 발생시킨다. 이를 해결하는 방법은 2가지가 있다.

###  첫번째 방법, Object 배열을 제네릭 타입 배열로 형변환하는 방법. 
            
```
public class Stack<E> {
    private E[] elements; // elements의 타입을 E[]로 둔다.
    private static final int CAPACITY = 16;
    
    @SuppressWarnings("unchecked")
    public Stack() {
        elements = (E[]) new Object[CAPACITY];
    }
}
```
        
### 두번째 방법, Object 배열을 그대로 사용하지만 배열내 원소를 사용시에 제네릭 타입으로 형변환 하는 방법
        
```
public class Stack<E> {
    private Object[] elements; // elements의 타입을 Object[]로 둔다.
    private static final int CAPACITY = 16;
    
    public Stack() {
        elements = new Object[CAPACITY];
    }
    
    public E pop() {
        . . .
        
        @SuppressWarnings("unchecked") E reuslt = (E) elements[--size];
        
        . . .
    }
}
```

두 방법 모두 컴파일 '경고'를 발생시키고, 타입 안전하지 않다.  개발자 스스로 타입이 안전한지 검증해야 하며, 증명되었다면 `@SuppressWarings` 애노테이션으로 해당 경고를 숨기자.

첫번쨰 방법이 가독성이 좋고 코드가 짧아서 선호되지만, 배열의 런타임 타입이 컴파일 타임 타입과 달라 힙 오염을 일으킨다. 힙오염이 맘에 걸린다면 두번쨰 방법을 사용하자.


# item30) 이왕이면 제네릭 메서드로 만들라

## 왜 제네릭 메서드로 만들어야 하는가? 
1. 타입 안정성과 가독성을 올릴 수 있다.
2. 클라이언트가 사용하기 편하다. (직접 형변환 하지 않아도 된다.)

## Q) 제네릭 메서드와 와일드카드의 차이점은 뭐지?
- 기능적으로 하는일이 같다.
- 차이점은 무엇인가..?
- p185를 보면 반환타입에는 한정적 와일드카드를 사용하지 말라고 되어있다. 클라이언트 코드에서도 와일드카드 타입을 써야하기 떄문이라고,,?

# item31) 한정적 와일드카드를 사용해 API 유연성을 높이라

## 정의
### 와일드카드 <?>
전제 : 제네릭 타입은 불공변이기 때문에, 설계시에 다형성을 활용 할 수 없다. 

그러므로, 제네릭 타입을 매개변수로 사용한 메소드를 만든다면 각각의 메서드를 오버로딩해야 할 것이다.
```
public void myMethod(List<Integer> list) {
    ...
}

public void myMethod(List<Double> list) {
    ...
}

public void myMethod(List<Long> list) {
    ...
}
```

이때, 와일드카드를 사용하면 유연한 설계가 가능하다.
```
public void myMethod(List<? extends Number> list) {
    ...
}
```

# item32) 제네릭과 가변인수를 함께 쓸 때는 신중하라.

## 제네릭 타입을 가변인수에서 사용하면 위험한 이유
가변인수를 담기 위한 '배열'이 만들어지기 때문이다. 제네릭타입이 배열에 담기는 일이 벌어진다. (실체화-비실체화)
```
static void myMethod(List<String>... strings){
    . . .
}
```
위 메서드를 컴파일 하면 List[] strings 배열이 될 것이다. 이제 힙오염(?)이 되어 저 배열에는 String 이외에 값들이 담기게 된다.

## 그래서 제네릭 타입을 가변인수에서 사용하고 싶다면? 

1. 코드를 작성하는 개발자는 메서드가 타입 안전함을 확인해야한다.
    - 타입 안전함을 확신할 수 있는 기준
    1. 메서드가 이 배열에 아무것도 저장하지 않아야 한다.
    2. 그 배열의 참조를 밖으로 노출시키지 않는다. (단, 신뢰 할 수 있는 코드라면 노출 할 수 있다. P194 신뢰할 수 있는 코드란, @Safevarargs로 '제대로'된 다른 varags 메서드거나, 일부 함수를 호출만 하는 경우)

2.  `@SafeVarargs` 애노테이션으로 비검사 경고를 해제한다. 
(자바7 이상 에서는 애노테이션이 없다면 컴파일 경고를 발생시킨다. 그전에는 클라이언트 쪽에서 매번 형변환시 `@SurpressWarnings("unchecked")`를 달았어야 했다.)


**이미 제네릭 타입으로 안전한 List.of() 같은 메서드를 활용하는 방안도 있다.**
