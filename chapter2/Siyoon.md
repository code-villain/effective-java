# item1) 생성자 대신 정적 팩터리 메서드를 고려하라.

## 정의
### 정적 팩토리 메서드
클래스의 인스턴스를 반환하는 정적 메서드

## 장점
1. 코드 가독성이 좋아지고 생성자간의 구분이 가능해진다. '이름'을 갖기 때문이다.
2. 클래스를 사용하는 사용자와 클래스 제공자 사이에, 중간다리를 만들 수 있다. (여기서 말하는 중간다리를 프록시라고 표현해도 될까?) 
    책에서는 4가지 장점을 설명하고 있다. 
        
	1. 호출될 때 마다 인스턴스를 새로 생성하지는 않아도 된다.
	2. 반환타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
	3. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
	4. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
    
    정적 팩터리 메서드가 생성자의 프록시(대리자) 역할을 하게 되어서, 일련의 작업을 수행할 수 있는 중간 단계가 존재하게 되었고 이로인한 장점이 생긴 것이다.

## 단점
1. 상속을 사용하지 못한다.
2. 설명이나 문서가 명확하지 않다면 사용하는 개발자 입장에서 사용하기가 어렵다.

# item2) 생성자의 매개변수가 많다면 빌더를 고려하라.

## 정의
### 점층적 생성자 패턴
클래스의 필드에 할당할 매개변수들을 선언하여서 생성자를 '여러개' 생성하는 패턴
- 클래스의 필드가 늘어나면 생성자도 늘어나고, 많은 필드를 대응하기 위해서 많은 생성자를 만들어야 한다. 그리고 사용자 입장에서 매개변수가 많아지면 어떤 값이 어떤식으로 들어가게 되는지 알기 어렵게 된다.

### 자바빈즈 패턴
자바빈즈 클래스로서 작동하기 위해서, 객체 클래스는 명명법, 생성법 그리고 행동에 관련된 일련의 관례를 따라야만 한다.
	- 클래스는 직렬화되어야 한다.(클래스의 상태를 지속적으로 저장 혹은 복원 시키기 위해)
	- 클래스는 기본 생성자를 가지고 있어야 한다.
	- 클래스의 속성들은 get, set 혹은 표준 명명법을 따르는 메서드들을 사용해 접근할 수 있어야 한다.
	- 클래스는 필요한 이벤트 처리 메서드들을 포함하고 있어야 한다.

출처 : https://ko.wikipedia.org/wiki/자바빈즈

- 3번쨰 관례가 적폐다. 객체의 캡슐화를 깨트리고 불변으로 만들기 어렵게 한다.

### '빌더'패턴
클래스를 생성하기 위한 별개의 클래스

## 장점
점층적 생성자 패턴과, 자바빈즈 패턴의 단점을 보완 할 수 있다. 즉 생성과정은 유연하면서 가독성이 좋고, 불변으로 만들기 쉽다.

# item3) private 생성자나 열거타입으로 싱글턴임을 보증하라.

## 정의
### 싱글턴
인스턴스를 오직 하나만 생성할 수 있는 클래스

### 장점
개발 안정성

# item4) 인스턴스화를 막으려거든 private 생성자를 사용하라.

## 장점
개발 안정성

# item5) 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라.

## 졍의
### 의존 객체 주입 패턴
인스턴스가 의존하는 객체를 직접 사용하지 않고 외부 (생성자나 setter)로 주입받는 방식

## 장점
의존 객체간의 결합도를 오지게 낮춘다.
결합도가 낮아지면 유지보수성과 테스트 용이성이 올라간다.

# item6) 불필요한 객체 생성을 피하라

## 장점
성능 향상, 특히 오토박싱이나 값 비싼 객체를 재활용 하지 않는 것을 조심하자.

# item7) 다 쓴 객체 참조를 해제하라

## 장점
메모리 성능 향상

- 가비지 컬렉터는 참조가 존재하는 객체는 수거해가지 않는다. 예제에서 스택내부에 존재하는 값들의 참조가 사라지지 않아서 계속해서 존재하는 문제가 생겼다.
- 내가 다루는 스프링 프로젝트에서 다음과 같은 일이 일어 날 수 있을까?
	- 음.. 만약에 사라지지 않는 빈의 필드로 컬렉션을 갖고 있고, 그 컬렉션에 자료가 필요없어질때, 참조를 해지하지 않는다면 가능할 것 같다. 일반적인 경우라면 거의 없을거 같음.

# item8) finalizer와 cleaner 사용을 피하라

## 정의
### finalizer & cleaner
객체를 명시적으로 소멸하게 만든다. finalizer는 자바8이전 cleaner는 자바9이상에서 사용한다.

### AutoCloseable 인터페이스
다 쓰고 닫아줘야 하는 객체는 AutoCloseable 인터페이스의 close()메소드를 구현하자. try-with-resource 구문을 사용할 때, 자동으로 close() 메소드를 호출해준다.

## 장점
finalizer와 cleaner는 실행시점을 예측할 수 없고 성능과 보안에 문제를 야기시킬 수 있다.
	- 만약 사용해야한다면??
		1. 클라이언트가 close()메서드를 호출하지 않는 것을 대비해서 보험으로 (안정망 역할로) 구현해둔다.
		2. 네이티브 메서드와 연결된 네이티브 피어 객체들은 가바지 컬렉터의 대상이 되지 않는다. 이런 경우에도 구현해 둘 수 있지만, 네이티브 피어 객체도 close() 메서드를 사용할 수 있다고 하니, 사실상 이 이유도 쓸떄가 없는듯..

# item9) try-finally 보다는 try-with-resources를 사용하라.

## 정의
### try-with-resources
자바7부터 지원 하는 문법방식, try{} 문 안에서 사용 될 객체를 미리 알려주고, AutoCloseable를 구현한 객체들은 try{}문이 끝날때 close() 메서드를 호출해준다.

## 장점
문법이 깔끔해지고, 실수를 방지한다. 
