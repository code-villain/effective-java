# item34) int 상수 대신 열거 타입을 사용하라.

## 정수 열거 패턴
정수 상수를 한대 묶어서 사용하는 패턴

## 열거 타입
enum

## 장점
1. 컴파일 타임의 타입 안정성을 보장한다. (정수 열거 패턴이라면 같은 정수 값을 사용한 다른 상수 변수를 구분할 수 없다.)
2. 싱글턴임이 보장된다.

# item35) ordinal 메서드 대신 인스턴스 필드를 사용하라.

## ordianl()
이넘에 명시된 필드의 순서를 반환하는 메서드. 

필드의 순서가 바뀌게 되면 의도하지 않은 행동이 나올 수 있다. 순서가 필요하다면 명시적으로 인스턴스 필드를 선언해서 값을 부여해주자.

# 비트 필드 대신 EnumSet을 사용하라

## 정의
### 비트 필드
정수 열거 패턴에 상수를 서로 다른 2의 거듭제곱으로 만든 필드. 비트 연산자를 사용 할 수 있어서 합집합 교집합 같은 집합 연산을 효율적으로 수행 할 수 있다는 장점이 있다.
그러나 비트 필드역시 정수 열거 패턴에 한 종류라 정수 열거 패턴의 단점을 모두 갖고 있다.

### EnumSet을 써야하는 이유
EnumSet은 Set인터페이스를 완벽하게 구현하였으며, 비트 필드에 연산처럼 효율적으로 처리 할 수 있는 연산을 써서 구현되어 있다.

그러므로 EnumSet을 사용하면 안전함과 성능을 모두 잡을 수 있다.

# item37) orinal 인덱싱 대신 EnumMap을 사용하라

# item38) 확장할 수 있는 열거타입이 필요하면 인터페이스를 사용하라.

- 열거타입(enum)은 상속을 이용한 확장을 할 수 없다.
- (대부분의 상황에서 확장을 열거타입을 하겠다는건 좋지 않은 생각이지만) 예외적으로 어울리는 쓰임은 '연산 코드'다.
    - 내 생각에 여기서 말하는 연산 코드란, 다형성을 활용하여서 연산되어야 하는 경우를 말하는 것 같다. 

    예를들어 이넘에 정의된 '함수(연산)'이 존재하고, 이 '함수'는 여러 이넘에 선언되어있다고 가정할 때, 
    
    여러 이넘에서 선언된 이 함수를 매개변수로 받아 사용되어야 한다면?

    **다형성**(상속)을 사용할 수 없는 이넘은 취약점이 생긴다. 이때 인터페이스로 연산을 뽑아낸다면 사용 가능하다.

    - 만약 구현의 중복을 제거 하고 싶다면, 디펄트메서드나 도우미 클래스 혹은 정적 도우미 메서드를 사용한다.

# itme 39) 명명 패턴보다 애노테이션을 사용하라

## 정의
### 명명 패턴
상징적인 이름으로 메서드나 클래스 따위를 구분하는 패턴 (ex: test로 시작하는 메서드는 테스트용 메서드다. = Junit3버전에서 사용하던 패턴)

명명패턴의 단점
1. 오타가 날 수 있다. 
2. 의도한대로 동작하는지 확인하기가 어렵다. 
3. 프로그램 요소를 매개변수로 전달할 방법이 없다. (예를들어 특정 예외타입을 전달한다던가.)

- 애노테이션을 사용하면 좀 더 명시적이고 리플렉션을 사용하여 특정 기능을 구현하기에 보다 쉽다.

# item 40) @Override 애노테이션을 일관되게 사용하라.
@Override 애노테이션을 사용하면 오버라이딩 실수를 컴파일러가 바로 알려준다.

# item 41) 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라.

## 정의
### 마커 인터페이스
**아무 메서드도 담고 있지 않고**, 단지 자신을 구현하는 클래스가 특정 속성을 가짐을 표시해주는 인터페이스. Serializable인터페이스가 좋은 예다.

### 마커 애노테이션
(정확한 정의는 책에 없지만,) 아무 기능도 없이 특정 속성을 나타내고 싶을때 사용하는 애노테이션을 말하는 것 같다.

### 마커 인터페이스의 장점 (마커 애노테이션에 비하여)
1. 인스턴스를 구분하는 타입으로 사용가능하다. (= 다형성 사용가능)
2. 적용 대상을 더 정밀하게 지정할 수 있다. '특정 인터페이스'를 구현한 클래스를 구분할 수 있다는 뜻

결론적으로 마커 애노테이션을 대부분의 경우 사용하는 것이 좋지만, 위의 장점 2가지를 고려해보고 사용해야 한다면 마커 인터페이스를 사용해야 한다.





