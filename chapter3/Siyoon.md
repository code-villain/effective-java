# item10) equals는 일반 규약을 지켜 재정의하라

## 정의
### equals()
다른 두개의 객체의 '논리적' 동치성을 확인하는 메소드. '논리적'이라는 말에 집중해보자. 물리적으로는 다른 객체를 '논리적'으로 같은것으로 볼지 안볼지는 그 객체를 어떤식으로 바라보느냐에 따라 달라진다.

## Object의 명세된 규약
1.*null이 아님*
2. 반사성 : x.equals(x)는 true
3. 대칭성 : x.equals(y)가 true 이면 y.equals(x)도 true
4. 추이성 : x.equals(y)가 true 이고, y.equals(z)가 true이면 x.equals(z)도 true
5. 일관성 : x.equals(y)를 반복해서 호출하면 항상 true이거나 false

## equlas를 재정의하지 않아도 되는 경우
1. 각 인스턴스가 본질적으로 고유한 경우 : (정적) 유틸 클래스를 말하는 것 같다. 값을 표현하지 않고 동작만을 하는 객체
2. '논리적' 동치성을 확인할일이 없는 경우
3. 상위클래스에서 재정의한 equlas가 잘 들어맞는 경우
4. 클래스가 private 혹은 패키지 접근자라 equlas를 호출할 일이 없는 경우
5. + 싱글톤임이 보장된 클래스 

## equals 메서드 구현 방법 4단계
1. == 연산자를 사용해 자기자신과 같은 참조인지 확인한다. *참조가 같으면 비교 할 것도 없이 동치*이기 때문이다.
2. instanceof 연산자로 비교해야 할 객체가 올바른 타입인지 확인한다. (꼭 같은 타입이 아니더라도 상위 타입으로 비교해야 할 수 도 있다.) *비교할 수 있는 타입이 아니라면 비교할 것도 없이 동치가 아니다.*
3. 입력을 올바른 타입으로 형변환한다.
4. 핵심필드들이 일치하는지 하나씩 확인해본다.

## 핵심필드 일치 여부 확인시에 주의할 점
- float와 double은 == 로 비교하지 말자. Float.compare()와 Double.compare()로 비교해야한다. 특수한 부동소수 값을 다뤄야 하기 때문
- 필드값이 null값이 정상으로 취급해야 하는 경우는 Objects.equals()로 비교해야 NPE를 예방할 수 있다.
- 성능에 따라 어떤 필드를 먼저 비교해야 할지 고려 할 수 있다. 비교 비용이 싼 필드부터 비교하자.
