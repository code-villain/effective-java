# item10) equals는 일반 규약을 지켜 재정의하라

## 정의
### equals()
다른 두개의 객체의 '논리적' 동치성을 확인하는 메소드. '논리적'이라는 말에 집중해보자. 물리적으로는 다른 객체를 '논리적'으로 같은것으로 볼지 안볼지는 그 객체를 어떤식으로 바라보느냐에 따라 달라진다.

## Object의 명세된 규약
1. **null이 아님**
2. 반사성 : x.equals(x)는 true
3. 대칭성 : x.equals(y)가 true 이면 y.equals(x)도 true
4. 추이성 : x.equals(y)가 true 이고, y.equals(z)가 true이면 x.equals(z)도 true
5. 일관성 : x.equals(y)를 반복해서 호출하면 항상 true이거나 false

## equlas를 재정의하지 않아도 되는 경우
1. 각 인스턴스가 본질적으로 고유한 경우 : (정적) 유틸 클래스를 말하는 것 같다. 값을 표현하지 않고 동작만을 하는 객체
2. '논리적' 동치성을 확인할일이 없는 경우
3. 상위클래스에서 재정의한 equlas가 잘 들어맞는 경우
4. 클래스가 private 혹은 패키지 접근자라 equlas를 호출할 일이 없는 경우
5. 싱글톤임이 보장된 클래스 (Enum 포함)

## equals 메서드 구현 방법 4단계
1. == 연산자를 사용해 자기자신과 같은 참조인지 확인한다. *참조가 같으면 비교 할 것도 없이 동치*이기 때문이다.
2. instanceof 연산자로 비교해야 할 객체가 올바른 타입인지 확인한다. (꼭 같은 타입이 아니더라도 상위 타입으로 비교해야 할 수 도 있다.) *비교할 수 있는 타입이 아니라면 비교할 것도 없이 동치가 아니다.*
3. 입력을 올바른 타입으로 형변환한다.
4. 핵심필드들이 일치하는지 하나씩 확인해본다.

### 핵심필드 일치 여부 확인시에 주의할 점
- float와 double은 == 로 비교하지 말자. Float.compare()와 Double.compare()로 비교해야한다. 특수한 부동소수 값을 다뤄야 하기 때문
- 필드값이 null값이 정상으로 취급해야 하는 경우는 Objects.equals()로 비교해야 NPE를 예방할 수 있다.
- 성능에 따라 어떤 필드를 먼저 비교해야 할지 고려 할 수 있다. 비교 비용이 싼 필드부터 비교하자

# item11) equals를 재정의하려거든 hashCode도 재정의 하라.

## 정의
### hasCode
객체 데이터 값을 기반으로 (정수타입의) 숫자로 변환한 값. 어떤 방식으로 숫자로 변환할 것인지는 해시함수에 따라 달려있다.
- 같은 객체라면 (당연히) 같은 해시값이 나와야 한다.
- equals()가 참이면 같은 해시값이 나와야 한다. (다르게 나올 수 도 있다. equals로 비교한 필드와, 해시값을 만드는데 사용한 필드가 다를 수 있으니)
- 다른 객체라도 같은 해시값이 나올 수 있다. 다만 이런 경우를 최소화 하는 해시함수를 만들어야 한다.

## hashCode()를 재정의 해야 하는 이유
Object의 기본 선언된 해시코드를 사용하게 되면, 같은 값의 객체라도 계속 '다른' 해시코드가 값을 뱉게 된다. (생각해보니 당연하네 어떤걸로 객체를 판단하라고 기준을 준적이 없으니 멋대로 판단해서 아무거나 주는듯)
Hash류의 컬렉션을 제대로 사용하기 위해서는 hashCode를 제대로 정의내려 줘야 한다.

## equals를 재정의 하지 않는다면 hashCode도 재정의 할 필요 없는 이유
아이템 제목에서 묘한 느낌을 받았는데 마치 equals를 재정의 하지 않았다면 굳이 hashCode는 재정의하지 않아도 된다는 늬앙스이기 떄문이다. 생각해보면 해시코드를 사용한다는건 객체를 엄밀히 구분하기 위해서 사용한다는 것이고 해시코드는 이에 도움을 주는 것이니 필요가 없다는 뜻이다!

## 이펙티브 자바 권고 hashCode 작성요령
- p68참고

간단히 핵심만 정리해보면
1. 기본타입들의 .hashCode()를 사용해서 해시코드를 불러온다. 
예를들어 int 타입이면 Integer.hashCode(field) (null 값은 0으로 판단)
2. 필드들은 equals에서 사용하는 필드와 같은 필드들로 구성해야 한다. (equals가 참일떄 해시코드가 같은 값을 만들기 위함)
3. 기본타입들의 해시코드값을 적절하게 곱하고 더해준다.
`result = 31 * result + c;`

+ 해시코드 작성방식을 클라이언트에게 공개하지 말자. 클라이언트가 이 값에 의존하여서 코딩하게 된다면. 더 나은 해시함수를 만들수 있는 가능성이 없기 때문이다.

# item12) toString을 항상 재정의하라

## 정의
### toString
객체의 값을 프로그래머가 의도한 대로 보기좋게 출력한다. 디버깅하기 쉬워진다.

# item13) clone 재정의는 주의해서 진행하라.

## 정의
### clone
객체 복사 메서드. 책에서는 배열 복사와 기존에 사용되고 있는 클래스를 수정하는  사용하라고 권고한다. 생성자나 정적 메서드르 통해서 복사하자.




