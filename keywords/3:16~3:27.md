__**JDragon**__
 키워드라...

---
__**Jaehee**__
 벌써 키워드 올릴때라니…

---
__**정시윤**__
 머야 오늘 화요일이네

---
__**정시윤**__
 내일까지잖아요

---
__**정시윤**__
 껄

---
__**JDragon**__
 ㅇ_ㅇ

---
__**김규민**__
 • 의존 객체 주입은 재사용성, 테스트 용이성을 엄청나게 개선해준다.

---
__**JDragon**__
 이시간에 ㄷㄷ

---
__**김규민**__
 퇴근을 늦게 해서염 ㅋ

---
__**김규민**__
 형은 1시 14분까지 ㄷㄷ

---
__**yjs**__
 ㄷㄷ? 야근지옥..

---
__**김규민**__
 이제 곧 끝이에요,, ㅋㅋㅋ

---
__**김규민**__
 이제 형이 오시면 야근하지 않아도 되는데 말이죠

---
__**김규민**__
 껄

---
__**yjs**__
 껄

---
__**JDragon**__
 ㄴㄴ 난 걍 공뷰

---
__**JDragon**__
 회사에서 이제 마스크도 만드나벼...

---
__**yjs**__
 오오 지급해 준건가요?

---
__**김규민**__
 오

---
__**김규민**__
 사기 힘드니 직접 만든다

---
__**김규민**__
 클라쓰

---
__**yjs**__
 근데 여기 키워드 채널 아닌가? ㅋ

---
__**정시윤**__
 아 키워드 묻힌다구요

---
__**정시윤**__
 키워드 관련 외 사담 금지

---
__**Jaehee**__
 그럼 한마디 써야겠다

---
__**김규민**__
 묻

---
__**Jaehee**__
 ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ

---
__**JDragon**__
 아 왜 여기다 올렸지

---
__**JDragon**__
 실수

---
__**JDragon**__
 해헷

---
__**yjs**__
 헤헷

---
__**yjs**__
 열거 타입의 싱글턴 (p.25)

---
__**yjs**__
 WeakHashMap (p.38)

---
__**yjs**__
 오토박싱 함부로 하지 말 것 (p.34)

---
__**yjs**__
 재귀적 타입 한정???? (p.20)

>__**정시윤**__	재귀적 + 타입 한정 합성어 같은데,
> 재귀적이란 키워드는 addTopping()에서 builder 자신을 계속 리턴해서 붙은거 같고,
> 타입 한정은 제네릭으로 제한시켰다는 말인거 같습니다

---
__**정시윤**__
 가능하면 페이지도 좀 적어주세요 아이템이라두

---
__**yjs**__
 빌더 타입은 왜 계층적 설계된 클래스와 함께 쓰기 좋은가? (p.19)

>__**정시윤**__	예제로 사용된 피자와 이를 상속받은 뉴욕피자 칼초네 피자를 빌터패턴을 안쓰고 구현해보는 걸 해봅시다.

>__**yjs**__	넹

---
__**정시윤**__
 자바빈즈 (페이지15)

>__**정시윤**__	<https://ko.wikipedia.org/wiki/자바빈즈>

---
__**정시윤**__
 Supplier<> (페이지 24)

---
__**정시윤**__
 Q) 페이지34 예제에 인스턴스가 231개가 만들어 진다는데 왜 231개 일까요? Integer.MAX_VALUE 라면 2,147,483,647개 아닐까요

---
__**Jaehee**__
 P16 자바빈즈 패턴 객체가 완전히 생성되기 전까지 일관성이 무너진 상태에 놓이게 된다..!!!

---
__**JDragon**__
 없음

---
__**Jaehee**__
 P52 인스턴스의 논리적 동치성을 검사할 일이 없다

---
__**JDragon**__
 이번주 뭐할지 아직 못정함

---
__**김규민**__
 이유를 찾았읍니다 껄껄

---
__**정시윤**__
 언넝말해

---
__**김규민**__
 231개가 아니라 2^31개였읍니다… ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ

---
__**정시윤**__
 아항

---
__**정시윤**__
 번역이 잘못한거?

---
__**정시윤**__
 오

---
__**정시윤**__
 2의 31승은 2147483647이 맞아

---
__**김규민**__
 -2^31 - 1 ~ 2^31

---
__**Jaehee**__
 P66 사람이 직접 작성하는 것보다는 IDE에 맡기는 편이 낫다 - 16페이지나 할애했지만 작성하지 말라는 결론^^

>__**김규민**__	IDE의 equals and hashcode 기능을 간단한 예제에 적용해봤더니, 62~63p에 정리된 사항들이 대부분 적용된 것을 확인할 수 있네요!!

>__**정시윤**__	인텔리제이?

>__**김규민**__	네

>__**정시윤**__	짱짱맨 AutoValue는 안해봤지

>__**김규민**__	찾아보기는 했는데 클래스 위에 @AutoValue 붙이는거 같더라구여?

>__**정시윤**__	롬복같이 쓰는거구나

>__**정시윤**__	와 짱텔리제이 미쳤다

>__**정시윤**__	성능까지 고려해서 참조타입보다 기본타입 먼저 비교함

>__**정시윤**__	찐따 롬복은 이런거 고려안하네

>__**정시윤**__	으휴

---
__**Jaehee**__
 P68 두 인스턴스를 같은 버킷에 담았더라도 - 같은 버킷에 담는다는게 뭐지????!!!!

>__**정시윤**__	쉽게 말해 배열의 인덱스라고 생각하시면 됩니다.

>__**김규민**__	key를 input으로 해서 hash 함수를 돌려서 나온 값이 버킷입니당

---
__**Jaehee**__
 P75 정적 유틸리티 클래스(아이템4)는 toString 을 제공할 이유가 없다 - 왜??

>__**김규민**__	객체 상태를 가지는 클래스가 아니라서?

>__**정시윤**__	정적 유틸리티 클래스는 (출력할만한)값이 없잖소.

---
__**Jaehee**__
 P86 기본 원칙은 복제 기능은 생성자와 팩터리를 이용하는게 최고 ... 배열만은 ... 합당한 예외 - 그래서 클론을 어디에 쓰냐!!고 생각이 들때쯤 배열에만 추천하며 마무리^^

>__**정시윤**__	조슈아블로크 개새끼

>__**김규민**__	와우..

>__**김규민**__	ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ

---
__**정시윤**__
 페이지71 코드11-4 쓰레드 안정성을 고려해서 hash code를 바로 안쓰고 별개의 변수를 선언했나봐

---
__**yjs**__
 전 이번주 패스 합니다

---
__**정시윤**__
 페이지77 "cloneable방식은 널리 쓰이고 있어서 잘 알아두는 것이 좋다"

---
__**정시윤**__
 아이템14 compare시에 - < >를 사용하면 안되는구나

---
__**김규민**__
 p52. “본질적으로 고유한 인스턴스“란, 값이 같은 인스턴스는 무조건 1개만 존재하는 클래스를 의미?

>__**정시윤**__	얘도 위에서 말한 정적 유틸 클래스 처럼 값이 의미 없고 동작만 하는 객체 클래스를 의미하는듯

---
__**김규민**__
 p62. “자신을 구현한 서로 다른 클래스끼리도 비교할 수 있도록 equals 규약을 수정” 했는지를 어떻게 알 수 있지? 여기서의 규약이란 어떤 규약을 말하는 걸까?

>__**정시윤**__	List 코드에 equals가 어떻게 되어 있나요?

>__**정시윤**__	지금 보니까 List 인터페이스에 equals() 메소드가 선언되어 있고, 어떤식으로 equlas()를 선언해야 하는지 주석으로 적혀있는데 이걸 ‘규약’이라고 보는거 같아요. 실제로 이를 구현한 AbstractList를 보면 이퀄스를 재정의 해두었고 인터페이스에서 주석으로 써둔 방식으로 재정의 해두었네요 호호호

---
__**김규민**__
 p85. 코드 13-7 복사 생성자 예제는

```
public Yum(Yum yum) {
  String foo = yum.getFoo();
  String bar = yum.getBar();
  return new Yum(foo, bar);
}
```

대략 이런 방식인걸로 생각하면 ~맞겠죠?~ 틀림

>__**정시윤**__	네 그런가봐요. 근데 같은 클래스라면 getter안쓰고 바로 접근 가능해요. 개념적으로 다른 객체라도

>__**정시윤**__	
> ```
> public Yum(Yum yum) {
>   String foo = yum.foo;
>   String bar = yum.bar;
>   return new Yum(foo, bar);
> }
> ```
> 

>__**김규민**__	어 아니네요

>__**김규민**__	getter 안써도 되는건 맞는데

>__**김규민**__	복사 생성자는

>__**김규민**__	
> ```
> public Yum(Yum yum) {
>     this.foo = yum.foo;
>     this.bar = yum.bar;
> }
> ```
> 
> 그냥 이런 애들인가봅니다

>__**김규민**__	제가 처음에 쓴 예제는 컴파일 에러남..

>__**김규민**__	위 예제는 shallow copy고, 객체 참조가 있는 경우엔 deep copy로 이렇게.
> 
> ```
> public class Yum {
> 
>     private String foo;
>     private String bar;
>     private LocalDate startDate;
> 
>     public Yum(final Yum yum) {
>         this.foo = yum.foo;
>         this.bar = yum.bar;
>         this.startDate = LocalDate.of(yum.startDate.getYear(), yum.startDate.getMonth(), yum.startDate.getDayOfMonth());
>     }
> }
> ```
> 
> 

---
