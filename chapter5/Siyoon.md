# item26) 로 타입은 사용하지 말라

## 정의
### 타입 매개변수(type parameter)
꺽쇠 < > 안에 들어가는 타입 한정자 매개변수

### 제네릭 클래스 (제네릭 인터페이스)
타입 매개변수를 사용한 클래스 (혹은 인터페이스)

### 제네릭 타입
제네릭 클래스 + 제네릭 인터페이스를 통틀어 제네릭 타입이라고 한다.

### 로(raw) 타입
제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다. (즉 제네릭 타입이 아닌 클래스는 로타입이라고 부르지 않는 다는 것이군)

로타입은 1.5버전 이하의 호환성을 위해서 가능하게 한것이다. 안정성과 표현력(가독성)을 떨어뜨린다. 절대로 사용해서는 안된다.

# item27) 비검사 경고를 제거하라.

= 컴파일러 (혹은 IDE) 말을 잘 듣자. 타입 안정성이 보장된다.

개발자가 보증할 수 있지만 경고를 제거 할 수 없는 경우에는 @SuperessWarnings 애노테이션을 달자. 가능한 좁은 범위에 달아야 한다.

# item28) 배열보다는 리스트를 사용하라.

= 배열보다는 '제네릭 타입인' 리스트를 사용하라.

## 배열 vs (제네릭타입) 리스트

### 공변(covariant) vs 불공변(invariant)
배열은 공변이다. 말이 어려운데 String[]은 Object[]의 하위타입이 된다. 다형성의 관점에서 생각해보자. 매개변수 타입이 Object[]로 되어 있다면 String[]도 받아들일 수 있다. 

반면에 (제네릭 타입) 리스트는 List<String>과 List<Object>는 엄밀히 구분된다. 매개변수 타입이 List<Object>라도 List<String>은 받을 수 없다. 다형적으로 받기 위해서 와일드카드<?>를 이떄 사용한다.

### 실체화(reifiable) vs 실체화 불가(non-reifiable)
제네릭 타입정보는 컴파일 이후에는 사라진다. 컴파일 이전까지만 타입안정성을 검사하고 '실체화'되지 않는다. 반면에 배열은 컴파일 이후에도 타입이 남아 '실체화' 된다. 이 때문에 배열과 (제네릭 타입인) 리스트를 섞어서 어우러지게 쓰기 어려운 것이다. 제네릭 타입은 타입 안정성을 추구해야 하는데, 실체화되지 않는 상황에서 배열에 들어가게 되면 이러한 강점이 사라지기 때문이다. 그래서 리스트 배열을 만드는 것은 불가능하도록 설정되었다. (페이지 165쪽)





