# item26) 로 타입은 사용하지 말라

## 정의
### 타입 매개변수(type parameter)
꺽쇠 < > 안에 들어가는 타입 한정자 매개변수

### 제네릭 클래스 (제네릭 인터페이스)
타입 매개변수를 사용한 클래스 (혹은 인터페이스)

### 제네릭 타입
제네릭 클래스 + 제네릭 인터페이스를 통틀어 제네릭 타입이라고 한다.

### 로(raw) 타입
제네릭 타입에서 타입 매개변수를 전혀 사용하지 않을 때를 말한다. (즉 제네릭 타입이 아닌 클래스는 로타입이라고 부르지 않는 다는 것이군)

로타입은 1.5버전 이하의 호환성을 위해서 가능하게 한것이다. 안정성과 표현력(가독성)을 떨어뜨린다. 절대로 사용해서는 안된다.

# item27) 비검사 경고를 제거하라.

= 컴파일러 (혹은 IDE) 말을 잘 듣자. 타입 안정성이 보장된다.

개발자가 보증할 수 있지만 경고를 제거 할 수 없는 경우에는 @SuperessWarnings 애노테이션을 달자. 가능한 좁은 범위에 달아야 한다.

# item28) 배열보다는 리스트를 사용하라.

= 배열보다는 '제네릭 타입인' 리스트를 사용하라. (그러나 리스트는 자바의 기본 타입이 아니다. 내부 구현시에 결국 배열을 사용해야 하는 경우가 있다. 아이템 29 참고)

## 배열 vs (제네릭타입) 리스트

### 공변(covariant) vs 불공변(invariant)
배열은 공변이다. 말이 어려운데 String[]은 Object[]의 하위타입이 된다. 다형성의 관점에서 생각해보자. 매개변수 타입이 Object[]로 되어 있다면 String[]도 받아들일 수 있다. 

반면에 (제네릭 타입) 리스트는 List<String>과 List<Object>는 엄밀히 구분된다. 매개변수 타입이 List<Object>라도 List<String>은 받을 수 없다. 다형적으로 받기 위해서 와일드카드<?>를 이떄 사용한다.

### 실체화(reifiable) vs 실체화 불가(non-reifiable)
제네릭 타입정보는 컴파일 이후에는 사라진다. 컴파일 이전까지만 타입안정성을 검사하고 '실체화'되지 않는다. 반면에 배열은 컴파일 이후에도 타입이 남아 '실체화' 된다. 이 때문에 배열과 (제네릭 타입인) 리스트를 섞어서 어우러지게 쓰기 어려운 것이다. 제네릭 타입은 타입 안정성을 추구해야 하는데, 실체화되지 않는 상황에서 배열에 들어가게 되면 이러한 강점이 사라지기 때문이다. 그래서 리스트 배열을 만드는 것은 불가능하도록 설정되었다. (페이지 165쪽)

# item 29) 이왕이면 제네릭 타입으로 만들라

왜 제네릭 타입으로 만들어야 하는가? -> item 26 로 타읍은 사용하지 말라를 참고해보면 타입 안정성과 가독성을 올릴 수 있다.

## 배열을 사용하는 제네릭 타입 만들기
제네릭 타입은 실체화 되지 않으므로 배열에 사용하게 되면 컴파일 '오류'를 발생시킨다. 이를 해결하는 방법은 2가지가 있다.

###  첫번째 방법, Object 배열을 제네릭 타입 배열로 형변환하는 방법. 
            
```
public class Stack<E> {
    private E[] elements; // elements의 타입을 E[]로 둔다.
    private static final int CAPACITY = 16;
    
    @SuppressWarnings("unchecked")
    public Stack() {
        elements = (E[]) new Object[CAPACITY];
    }
}
```
        
### 두번째 방법, Object 배열을 그대로 사용하지만 배열내 원소를 사용시에 제네릭 타입으로 형변환 하는 방법
        
```
public class Stack<E> {
    private Object[] elements; // elements의 타입을 Object[]로 둔다.
    private static final int CAPACITY = 16;
    
    public Stack() {
        elements = new Object[CAPACITY];
    }
    
    public E pop() {
        . . .
        
        @SuppressWarnings("unchecked") E reuslt = (E) elements[--size];
        
        . . .
    }
}
```

두 방법 모두 컴파일 '경고'를 발생시키고, 타입 안전하지 않다.  개발자 스스로 타입이 안전한지 검증해야 하며, 증명되었다면 `@SuppressWarings` 애노테이션으로 해당 경고를 숨기자.

첫번쨰 방법이 가독성이 좋고 코드가 짧아서 선호되지만, 배열의 런타임 타입이 컴파일 타임 타입과 달라 힙 오염을 일으킨다. 힙오염이 맘에 걸린다면 두번쨰 방법을 사용하자.


# item30) 이왕이면 제네릭 메서드로 만들라
